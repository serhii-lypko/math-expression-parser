import { Token, TokenType } from "./token.ts";

const { log, error } = console;

/// Formally speaking, RPN is generated by the post-order traversal of an AST

export class Parser {
  tokenStream: Token[];
  outputQueue: Token[];
  operatorsStack: Token[];

  constructor(tokensStream: Token[]) {
    this.tokenStream = tokensStream;
    this.outputQueue = [];
    this.operatorsStack = [];
  }

  public rpn(): Token[] {
    this.tokenStream.forEach((t) => {
      switch (t.type) {
        case TokenType.Literal:
        case TokenType.Variable:
          this.outputQueue.push(t);
          break;
        case TokenType.Operator:
          if (t.isOperator) {
            if (
              this.isStackEmpty ||
              this.latestOperator.isLeftParenthesis ||
              t.operatorPrec > this.latestOperator.operatorPrec
            ) {
              this.operatorsStack.push(t);
            } else {
              /// If the operator's precedence is lower than that of the operators at the top of the stack
              /// or the precedences are equal and the operator is left associative, then that operator
              /// is popped off the stack and added to the output
              while (
                t.operatorPrec < this.latestOperator?.operatorPrec ||
                (this.latestOperator?.operatorPrec == t.operatorPrec && t.isLeftAssoc)
              ) {
                const token = this.operatorsStack.pop();
                if (token) {
                  this.outputQueue.push(token);
                }
              }

              this.operatorsStack.push(t);
            }
          }
          break;
        case TokenType.LeftParenthesis:
          this.operatorsStack.push(t);
          break;
        case TokenType.RightParenthesis:
          /// Until the token at the top of the stack is a left parenthesis, pop operators off the stack
          /// onto the output queue
          while (this.latestOperator && !this.latestOperator?.isLeftParenthesis) {
            const token = this.operatorsStack.pop();
            if (token) {
              this.outputQueue.push(token);
            }
          }

          /// Pop the left parenthesis from the stack, but not onto the output queue
          this.operatorsStack.pop();

          break;
        case TokenType.Comma:
          // TODO functions and their arguments
          break;
      }
    });

    /// Any remaining operators are popped off the stack and added to the output
    const remainingOperators = this.operatorsStack.reverse();

    this.outputQueue = [...this.outputQueue, ...remainingOperators];

    const printed = this.printOutput();

    log(printed);

    return this.outputQueue;
  }

  printOutput() {
    return this.outputQueue.map((t) => t.value).join(" ");
  }

  private get latestOperator() {
    return this.operatorsStack[this.operatorsStack.length - 1];
  }

  private get isStackEmpty() {
    return this.operatorsStack.length === 0;
  }
}

export default Parser;
